// Auto-generated. Do not edit!

// (in-package hri_actions_msgs.msg)


"use strict";

const _serializer = _ros_msg_utils.Serialize;
const _arraySerializer = _serializer.Array;
const _deserializer = _ros_msg_utils.Deserialize;
const _arrayDeserializer = _deserializer.Array;
const _finder = _ros_msg_utils.Find;
const _getByteLength = _ros_msg_utils.getByteLength;

//-----------------------------------------------------------

class FaceOverlayGoal {
  constructor(initObj={}) {
    if (initObj === null) {
      // initObj === null is a special case for deserialization where we don't initialize fields
      this.media_url = null;
      this.duration = null;
      this.layer = null;
      this.layout = null;
      this.scale = null;
      this.offset_x = null;
      this.offset_y = null;
      this.fade = null;
    }
    else {
      if (initObj.hasOwnProperty('media_url')) {
        this.media_url = initObj.media_url
      }
      else {
        this.media_url = '';
      }
      if (initObj.hasOwnProperty('duration')) {
        this.duration = initObj.duration
      }
      else {
        this.duration = 0.0;
      }
      if (initObj.hasOwnProperty('layer')) {
        this.layer = initObj.layer
      }
      else {
        this.layer = 0;
      }
      if (initObj.hasOwnProperty('layout')) {
        this.layout = initObj.layout
      }
      else {
        this.layout = 0;
      }
      if (initObj.hasOwnProperty('scale')) {
        this.scale = initObj.scale
      }
      else {
        this.scale = 0.0;
      }
      if (initObj.hasOwnProperty('offset_x')) {
        this.offset_x = initObj.offset_x
      }
      else {
        this.offset_x = 0.0;
      }
      if (initObj.hasOwnProperty('offset_y')) {
        this.offset_y = initObj.offset_y
      }
      else {
        this.offset_y = 0.0;
      }
      if (initObj.hasOwnProperty('fade')) {
        this.fade = initObj.fade
      }
      else {
        this.fade = false;
      }
    }
  }

  static serialize(obj, buffer, bufferOffset) {
    // Serializes a message object of type FaceOverlayGoal
    // Serialize message field [media_url]
    bufferOffset = _serializer.string(obj.media_url, buffer, bufferOffset);
    // Serialize message field [duration]
    bufferOffset = _serializer.float32(obj.duration, buffer, bufferOffset);
    // Serialize message field [layer]
    bufferOffset = _serializer.uint8(obj.layer, buffer, bufferOffset);
    // Serialize message field [layout]
    bufferOffset = _serializer.uint8(obj.layout, buffer, bufferOffset);
    // Serialize message field [scale]
    bufferOffset = _serializer.float32(obj.scale, buffer, bufferOffset);
    // Serialize message field [offset_x]
    bufferOffset = _serializer.float32(obj.offset_x, buffer, bufferOffset);
    // Serialize message field [offset_y]
    bufferOffset = _serializer.float32(obj.offset_y, buffer, bufferOffset);
    // Serialize message field [fade]
    bufferOffset = _serializer.bool(obj.fade, buffer, bufferOffset);
    return bufferOffset;
  }

  static deserialize(buffer, bufferOffset=[0]) {
    //deserializes a message object of type FaceOverlayGoal
    let len;
    let data = new FaceOverlayGoal(null);
    // Deserialize message field [media_url]
    data.media_url = _deserializer.string(buffer, bufferOffset);
    // Deserialize message field [duration]
    data.duration = _deserializer.float32(buffer, bufferOffset);
    // Deserialize message field [layer]
    data.layer = _deserializer.uint8(buffer, bufferOffset);
    // Deserialize message field [layout]
    data.layout = _deserializer.uint8(buffer, bufferOffset);
    // Deserialize message field [scale]
    data.scale = _deserializer.float32(buffer, bufferOffset);
    // Deserialize message field [offset_x]
    data.offset_x = _deserializer.float32(buffer, bufferOffset);
    // Deserialize message field [offset_y]
    data.offset_y = _deserializer.float32(buffer, bufferOffset);
    // Deserialize message field [fade]
    data.fade = _deserializer.bool(buffer, bufferOffset);
    return data;
  }

  static getMessageSize(object) {
    let length = 0;
    length += _getByteLength(object.media_url);
    return length + 23;
  }

  static datatype() {
    // Returns string type for a message object
    return 'hri_actions_msgs/FaceOverlayGoal';
  }

  static md5sum() {
    //Returns md5sum for a message object
    return '953d334319802dfd447bdb6867044fd8';
  }

  static messageDefinition() {
    // Returns full string definition for message
    return `
    # ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======
    
    
    # URL of the picture/animation to overlay on the face; currently only supports
    # absolute local path
    string media_url
    
    # duration, in seconds, of the overlay visibility
    # - if the duration is larger than the duration of the animation, the animation
    # will loop.
    # - a duration of 0 means 'forever'. In this case, the action *will never
    # complete* on its own. Cancelling the action will remove the overlay from the
    # face.
    float32 duration
    
    
    ###############################################
    ## LAYER
    
    # display the image in the background (the eye's iris/pupil will be drawn on
    # top of the overlay
    uint8 BACKGROUND=0
    # display the image on top of the eye (the eye's iris/pupil will be occluded by
    # the image, except where transparent)
    uint8 FOREGROUND=1
    
    # one of BACKGROUND or FOREGROUND
    uint8 layer
    
    ###############################################
    ## LAYOUT
    
    # extend the provided image to cover both eyes.
    # Note: this typically is the only sensible option for robot with a single face panel
    uint8 EXTEND=0
    # on robots with 2 panels (one per eye), copy the provided image onto each eye
    uint8 COPY=1
    #  on robots with 2 panels (one per eye), mirror the provided image onto each eyes (symmetry over the vertical axis)
    uint8 MIRROR=2
    # on robots with 2 panels (one per eye), only display the image on the left eye
    uint8 LEFT_EYE_ONLY=3
    # on robots with 2 panels (one per eye), only display the image on the right eye
    uint8 RIGHT_EYE_ONLY=4
    
    # one of the layout constant defined above
    uint8 layout
    
    
    # scale of the image: 1.0 (default) means full width of the face/eye (depending
    # on the chosen layout); 0.1 means 10% of the width.
    # Note that any value <= 0.0 is ignored (replaced by 1.0)
    float32 scale
    
    # position offset, expressed as a proportion of the face or eye's width/height. Values
    # in [-1.0, 1.0] range.
    #
    # (0.0, 0.0) means that the image is centered with the face/eye
    # (-1.0, 1.0) means that the image's center would be located in the top left
    # corner of the face/eye panel.
    float32 offset_x
    float32 offset_y
    
    ###############################################
    ## EFFECTS
    
    # if true, the overlay will fade in/fade out
    bool fade
    
    
    `;
  }

  static Resolve(msg) {
    // deep-construct a valid message object instance of whatever was passed in
    if (typeof msg !== 'object' || msg === null) {
      msg = {};
    }
    const resolved = new FaceOverlayGoal(null);
    if (msg.media_url !== undefined) {
      resolved.media_url = msg.media_url;
    }
    else {
      resolved.media_url = ''
    }

    if (msg.duration !== undefined) {
      resolved.duration = msg.duration;
    }
    else {
      resolved.duration = 0.0
    }

    if (msg.layer !== undefined) {
      resolved.layer = msg.layer;
    }
    else {
      resolved.layer = 0
    }

    if (msg.layout !== undefined) {
      resolved.layout = msg.layout;
    }
    else {
      resolved.layout = 0
    }

    if (msg.scale !== undefined) {
      resolved.scale = msg.scale;
    }
    else {
      resolved.scale = 0.0
    }

    if (msg.offset_x !== undefined) {
      resolved.offset_x = msg.offset_x;
    }
    else {
      resolved.offset_x = 0.0
    }

    if (msg.offset_y !== undefined) {
      resolved.offset_y = msg.offset_y;
    }
    else {
      resolved.offset_y = 0.0
    }

    if (msg.fade !== undefined) {
      resolved.fade = msg.fade;
    }
    else {
      resolved.fade = false
    }

    return resolved;
    }
};

// Constants for message
FaceOverlayGoal.Constants = {
  BACKGROUND: 0,
  FOREGROUND: 1,
  EXTEND: 0,
  COPY: 1,
  MIRROR: 2,
  LEFT_EYE_ONLY: 3,
  RIGHT_EYE_ONLY: 4,
}

module.exports = FaceOverlayGoal;
