#!/usr/bin/python3

import rospy
from gpt_server.srv import GPTGenerate, GPTGenerateRequest, GPTGenerateResponse
from openai import OpenAI
import json
import pandas as pd
import sys
import os 
import random
from std_msgs.msg import String

from nltk.sentiment.vader import SentimentIntensityAnalyzer


class GPT:
    """
    ChatGPT server class.
    This will run in the background, waiting for a request to be made.
    GPT server accepts a string as request and outputs a string generated by ChatGPT.
    """

    def __init__(self):
        self.sentimentAnalyser = SentimentIntensityAnalyzer()

        rospy.init_node('gpt_server')
        id = rospy.get_param('~id','test')
        self.service = rospy.Service('gpt_generate', GPTGenerate, self.OnRequest)
        # intialize the chat history
        self.history_file_path = f'/home/robocupathome/workspace/eddy_code/src/DATA/{id}/chat_history.json'
        self.messages = []
        rospy.loginfo('GPT node started')

        # Here, initialize ChatGPT-3.5 Turbo
        self.client = OpenAI(api_key="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")
        # self.messages = ""
        self.user_profile=""
        self.history = ""
        # Extract the profile from the JSON file
        json_file_path = f'/home/robocupathome/workspace/eddy_code/src/DATA/{id}/profile.json'
        # self.emotion = "neutral"
        # set the timer for the topic changing
        self.topic_changer = self.TopicChanger(json_file_path)
        self.to_change_topic = True # set the flag to change the topic
        # once the below function is executed, then we set the flag to call TopicChanger to change the topic
        self.Totimer = rospy.Timer(rospy.Duration(120), self.set_topic_flag)
        self.profile =""
        with open(json_file_path, "r") as json_file:
            self.profile = json.load(json_file)

        self.screen_pub = rospy.Publisher('dialogue_robot',String, queue_size=10)


        self.emotiondetection_realtime = rospy.Subscriber('emotiondetect_result', String, self.emotion_result_callback)
        self.realtime_emotion = "neutral"

    def emotion_result_callback(self, data):
        self.realtime_emotion = data.data
        # print(f'Emotion detected: {self.realtime_emotion}')
        return self.realtime_emotion



    def set_topic_flag(self,event=None):
        # set the flag to change the topic
        self.to_change_topic = True

    def OnRequest(self, data: GPTGenerateRequest):
        text_from_speech = data.request  # Speech recognized by the user
        # self.emotion = data.initialEmotion

        # finalEmotion = data.finalEmotion
        input_text = {"role": "user", "content": text_from_speech}
        sentiment = self.sentimentAnalyser.polarity_scores(text_from_speech)['compound']
        sentimentstr = ''

        if sentiment < -0.05:
            sentimentstr = 'negative'
        elif sentiment > 0.05:
            sentimentstr = 'positive'
        else:
            sentimentstr = 'neutral'

        text_to_append = {"role": "user", "content": text_from_speech, "emotion": self.realtime_emotion, "sentiment": sentimentstr, "sentiment_score": sentiment}
        # Append the user's input to the conversation history -> the dialogue
        self.append_to_json(text_to_append, self.history_file_path)
        print(f'Receive emotions: {self.realtime_emotion}')
        self.messages.append(input_text) # append user speech into the message

        rospy.loginfo(f"Received a request with a prompt:\n{text_from_speech}")

        # here we detect whether to change the topic or not
        if self.to_change_topic == True or text_from_speech.lower() == "new topic":
            # change topic and close the flag, ready for next topic
            question, answer = self.topic_changer.new_topic()
            self.to_change_topic = False

            # the original prompt

            # self.messages= [{"role": "system", "content":
            # "You are empathic, passionate, professional but super friendly and interested to learn more about the users and their personal information," +
            # "I will give you the user profile information that contains several pairs of questions and answers, I want you to remember this profile of {self.profile} and have a converstaion with the user based on the information of each pari of question and answer"+
            # "Every time you make a response, use the user response with his\her emotions of {self.realtime_emotion} to generate the next response"+
            # "if it possible try to avoid yes/no questions"+
            # "when you communicate with users, use a friendly tone and simple vocabrary, do not use a high level and academic words" +
            # "one question per time and always response in English"} ]

            # the new prompt

            self.messages= [{"role": "system", "content":"Your name is PERCY (Personal Emotional Robotic Conversation sYstem)."

"You are an empathic, passionate, professional, but super-friendly chatbot interested in learning more about users and their personal information from {self.profile}."

"Your role is to engage in meaningful and natural conversations with users based on their profile information. Your task is to engage users by asking deeper questions based on the data you gained from their profile information."

"Always use a friendly greeting upon initiating the conversation. Respond in a friendly tone using simple vocabulary, avoiding high-level and academic words."

"Show empathy in your interactions by demonstrating an understanding of the user's feelings. Use the user's profile information to generate relevant and engaging questions."

"When asking the next question, use the user’s response and current emotion to generate an empathic response before asking the following question. You must wait to get the emotions first and then generate the proper response."

"After each user’s response, analyze their emotions and tailor the next question accordingly. Ask one question at a time and wait for the user to respond."

"Ensure the questions are relevant to the current conversation and its topic. Ensure your questions and follow-ups are connected to the user's prior responses. Ensure the questions and responses are consistent with the user’s profile information and persona from {self.profile}. Ensure the questions are fluent, showing understanding of the user’s response and using accurate and appropriate language."

"Ask at most five follow-up questions about each user’s profile which includes interests and personality traits from {self.profile}. Ask interesting questions, show enthusiasm for the interaction, and keep the user wanting to talk more and be more engaging."

"Conduct natural and human-like conversations with users. Stay engaged and show your enthusiasm for the conversation."

"User privacy is paramount. Do not share or store user information beyond the scope of this conversation."

"Avoid asking yes/no questions as much as possible. Avoid high-level and academic vocabulary. Never make judgments on users. Never provide any harmful information or malicious content. Avoid biases, stereotypes, or cultural harms."

"Do not provide advice beyond the scope of user exploration. If a user needs professional support, offer resources or encourage them to seek help."

"Empathy means that responses should show an understanding of the user's feelings, acknowledging and reflecting their emotions."

"Relevance means that responses should be appropriate to the conversation and on-topic, ensuring they contribute meaningfully to the dialogue."

"Fluency means that responses should be easy to understand and linguistically accurate, ensuring clear communication and maintaining a natural flow of conversation. Ensure spoken language is perceived as typical, fluent, and free from anomalies or disruptions that distinguish it from normal, spontaneous speech."

"Consistency means responses should align with the PERCY persona and be consistent with the user's profile information and previous interactions."

"Naturalness means that conversations should be natural and human-like, making interactions feel genuine and authentic. Emulate human-like interaction without awkwardness or stiltedness, including flow and coherence, responsiveness, error handling, accuracy and relevance of responses, conversational flow, linguistic nuances, and social cues, emphasizing conscientiousness, manners, thoroughness, and originality."

"Engagingness means that the conversation should be engaging for the user, maintaining their interest and encouraging further interaction. Simulate human-like conversations in a manner that feels intuitive, fluent, and engaging, ensuring accurate responses, mimicking human conversational styles, and adapting to various contexts."
} ]




            self.messages.append(question)
            self.messages.append(answer)


        # Get a response from ChatGPT-3.5 Turbo
        response = self.get_openai_response(self.messages)

        # Append the response to the conversation
        self.messages.append({"role": "assistant", "content": response})

        print(f'Received a request with a prompt:\n{input_text}')
        response_to_append = {"role": "assistant", "content": response}
        # append to the chat history
        self.append_to_json(response_to_append, self.history_file_path)
        print(self.messages)
        display_response = f'Role: Robot, Content: {response}'
        self.screen_pub.publish(display_response)
        
        return response
   
    def get_openai_response(self, messages):
        chat = self.client.chat.completions.create(model="gpt-3.5-turbo", messages=messages)
        reply = chat.choices[0].message.content 
        return reply
        # return GPTGenerateResponse(response=reply)

    def append_to_json(self, data, file_path):
        # Check if the JSON file exists
        if os.path.exists(file_path):
            # If file exists, read existing JSON data
            with open(file_path, 'r') as json_file:
                existing_data = json.load(json_file)
        else:
            # If file doesn't exist, initialize with an empty list
            existing_data = []

        # Append new data to the existing data
        existing_data.append(data)

        # Write the updated data back to the JSON file
        with open(file_path, 'w') as json_file:
            json.dump(existing_data, json_file, indent=4)
    
    # def print_flag(self):
    #     rate = rospy.Rate(1)  # Rate of 1 Hz (1 message per second)
    #     while not rospy.is_shutdown():
    #         rate.sleep()  # Sleep to maintain the desired rate


    class TopicChanger:
        def __init__(self,json_path):
            # Create a set to store all the printed pairs 
            self.printed_pairs = set()
            # Specify the path to the JSON file
            self.json_path = json_path
            self.current_index = 0
            # Load the JSON data from the file
            with open(self.json_path) as f:
                self.json_data = json.load(f)

        def new_topic(self):
            if self.current_index < len(self.json_data):
                pair = self.json_data[self.current_index]
                question = pair[0]['content']
                answer = pair[1]['content']
                if (question, answer) not in self.printed_pairs:
                    print("Question:", question) 
                    print("Answer:", answer)
                    print()
                    self.printed_pairs.add((question, answer))
                    self.current_index += 1
                    rospy.logwarn(f"Current Topic Index: {self.current_index}, There are {len(self.json_data)-self.current_index} topics left. Changed to new topic {question}")
                    return {"role": "assistant", "content": question}, {"role": "user", "content": answer}
            else:
                rospy.logwarn("All Topics Discussed")
                rospy.signal_shutdown("All Topics Discussed")
 
     
          

if __name__ == '__main__':
    gpt = GPT()
    # gpt.print_flag()
    rospy.spin()