#! /usr/bin/python3

import rospy

from gpt_server.srv import GPTGenerate, GPTGenerateResponse, GPTGenerateRequest  # Import GPT service definition
from emotion_server.srv import EmotionGenerate, EmotionGenerateResponse
from hri_msgs.msg import LiveSpeech

from actionlib import SimpleActionClient
from pal_interaction_msgs.msg import TtsAction, TtsGoal

from sensor_msgs.msg import Image

import numpy as np

from deepface import DeepFace


from pyhri import HRIListener



class Node:

    def __init__(self):
        rospy.init_node('gpt_research')

        # Connect to the GPT server.
        # From now one, when you want to receive response from chatgpt, you can do:
        # response = self.gptServer(prompt)
        print('Waiting for GPT server to be availale')
        self.gptServer = rospy.ServiceProxy('/gpt_generate', GPTGenerate)
        self.gptServer.wait_for_service()
        print('Successfully connected to /gpt_generate')

        #print('Waiting for Emotion server to be availale')
        #self.emotionServer = rospy.ServiceProxy('/emotion_generate', EmotionGenerate)
        #self.emotionServer.wait_for_service()
        #print('Successfully connected to /emotion_generate')

        self.hri = HRIListener()

        # Subscribe to speech recognition topic. Whenever speech is received, OnSpeechReceived() is invoked.
        self.humanSpeech = rospy.Subscriber('/humans/voices/anonymous_speaker/speech', LiveSpeech, self.OnSpeechReceived)

        # Publish to /tts
        self.tts = SimpleActionClient('/tts', TtsAction)
        self.tts.wait_for_server()

        print('Successfully connected to /tts')


        self.initialConversation = True
        self.initialEmotion = ''
        self.finalEmotion = ''

    
    def OnSpeechReceived(self, data:LiveSpeech):

        if self.initialConversation and len(data.incremental) > 0:
            self.initialConversation = False

            # Get a new emotion
            self.initialEmotion = ''

            # Extract and receive the emotion, assumed there is only one person and the face is visible throughout the conversation.
            for id, person in self.hri.tracked_persons.items():
                if person.face:
                    if person.face.aligned is not None and person.face.aligned.any():
                        demography = DeepFace.analyze(img_path=person.face.aligned,actions=['emotion'], enforce_detection=False)
                        result = demography[0]
                        emotion = result['dominant_emotion']

                        self.initialEmotion = emotion

        # Only process when the user finished speaking.
        if len(data.final) > 0:
            # Get a new emotion
            self.finalEmotion = ''

            # Extract emotion
            for id, person in self.hri.tracked_persons.items():
                if person.face:
                    if person.face.aligned is not None and person.face.aligned.any():
                        demography = DeepFace.analyze(img_path=person.face.aligned,actions=['emotion'], enforce_detection=False)
                        result = demography[0]
                        emotion = result['dominant_emotion']

                        self.finalEmotion = emotion
            
            rospy.sleep(duration=rospy.Duration(secs = 0.5))

            print(f'Obtained Emotions: Init - {self.initialEmotion}, Final - {self.finalEmotion}')

            print('Generating response for the following sentence:')
            print(data.final)
            # Generate response from ChatGPT and make the robot speak.

            request = GPTGenerateRequest()
            request.request = data.final
            request.initialEmotion = self.initialEmotion
            request.finalEmotion = self.finalEmotion

            response:GPTGenerateResponse
            response = self.gptServer(request)

            output = response.response  # The actual string generated by GPT

            # Publish to /tts, make the robot speak.
            msg = TtsGoal()
            msg.rawtext.lang_id = 'en_GB'
            msg.rawtext.text = output

            self.tts.send_goal_and_wait(msg)

            print('Generated Response:')
            print(output)

            print('done')
            self.initialConversation = True


if __name__ == '__main__':
    node = Node()
    rospy.spin()